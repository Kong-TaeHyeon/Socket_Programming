# 들어가며.

소켓 통신을 직접 Java를 통해 구현하며, 4계층의 대한 이해를 하기 위함!

## 소켓 통신

네트워크 상에서 두 프로그램이 데이터를 주고 받기 위하 사용하는 통신 방식이다.

소켓은 **네트워크를 통해 데이터를 송수신할 수 있도록 운영체제가 제공하는 인터페이스**이다. 소켓을 사용하면 **마치 파일을 읽고 쓰듯이** 네트워크를 통해 데이터를 주고 받을 수 있다.

### TCP

두 프로그램 사이에 논리적인 접속을 성립하기 위하여 연결을 설정하여 신뢰성을 보장하는 **연결형 서비스**이다.

데이터 단위는 **세그먼트**(메시지 -> 세그먼트 -> 패킷 -> 프레임)이다.

#### TCP의 특징

1. **연결형 서비스**

연결형 서비스로 가상 회선 방식을 제공한다.

- 3-way handshaking 과정을 통해 연결을 설정.
- 4-way handshaking 과정을 통해 연결을 해제.

2. **흐름 제어(Flow Control)**

데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지.

- 송신하는 곳에서 감당이 안되게 많은 데이터를 빠르게 보내 수신하는 곳에서 문제가 일어나는 것을 막는다.
- 수신자가 **윈도우 크기(Window Size) 값을 통해 수신량을 정할 수 있다**.
- 이는 연결 설정 과정(Hand Shake)에서 초기 값을 설정하고, 이후 수신자의 ACK 패킷을 통해 값을 변경할 수 있다.

3. **오류 제어 (Error Control)**

   1. **Stop and Wait ARQ**  
      송신측에서 1개의 프레임을 송신하고 수신 측에서 수신된 프레임의 에러 유무 판단에 따라 ACK 또는 NAK를 보내는 방식이다.

      <img src="image/image1.png" width="400">

      위 그림과 같이 하나의 데이터에 대한 응답을 기다려야 하기 때문에 효율이 떨어진다.

   2. **Go-Back-n ARQ**  
      패킷을 전송할 때, 하나의 패킷을 수신하지 못하면 해당 패킷부터 다시 전송하는 기법이다!

      <img src="image/image2.png" width="400">

      기본적으로 Stop and Wait 방식보단 효율이 좋지만, 패킷 손실이 발생하면 중복된 데이터들을 전송하므로 효율이 떨어질 수 있다.

   3. **Selective-Repeat ARQ**  
      위의 두 방식과는 다르게, 받지못한 ACK에 대한 데이터만 선택적으로 재전송하는 기법이다.

4. **혼잡제어(Congestion control)**
   송신 측의 데이터 전달과 네트워크 데이터 처리 속도를 해결하기 위한 기법이다. 네트워크 혼잡을 피하기 위해 송신 측에서 보내는 데이터의 전송 속도를 제어하는 것이다.

   - Slow Start.
     패킷이 문제 없이 도착하면 각각의 ACK 패킷마다 Window Size를 늘려가는 방식이다.

#### TCP 소켓 연결 과정

<img src="image/image3.png" width="400">
